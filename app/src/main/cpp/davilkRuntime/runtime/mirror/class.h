//
// Created by thehepta on 2024/8/15.
//

#pragma once
#include "object.h"
#include "runtime/dex_file.h"
#include <unordered_map>

class ClassLoader;
class DexCache;
class String;
class ClassExt;
class IfTable;
class PointerArray;
class MANAGED  __attribute__((unused)) Class final : public Object {

// Defining class loader, or null for the "bootstrap" system loader.
    HeapReference<ClassLoader> class_loader_;

    // For array classes, the component class object for instanceof/checkcast
    // (for String[][][], this will be String[][]). null for non-array classes.
    HeapReference<Class> component_type_;

    // DexCache of resolved constant pool entries (will be null for classes generated by the
    // runtime such as arrays and primitive classes).
    HeapReference<DexCache> dex_cache_;

    // Extraneous class data that is not always needed. This field is allocated lazily and may
    // only be set with 'this' locked. This is synchronized on 'this'.
    // TODO(allight) We should probably synchronize it on something external or handle allocation in
    // some other (safe) way to prevent possible deadlocks.
    HeapReference<ClassExt> ext_data_;

    // The interface table (iftable_) contains pairs of a interface class and an array of the
    // interface methods. There is one pair per interface supported by this class.  That means one
    // pair for each interface we support directly, indirectly via superclass, or indirectly via a
    // superinterface.  This will be null if neither we nor our superclass implement any interfaces.
    //
    // Why we need this: given "class Foo implements Face", declare "Face faceObj = new Foo()".
    // Invoke faceObj.blah(), where "blah" is part of the Face interface.  We can't easily use a
    // single vtable.
    //
    // For every interface a concrete class implements, we create an array of the concrete vtable_
    // methods for the methods in the interface.
    HeapReference<IfTable> iftable_;

    // Descriptor for the class such as "java.lang.Class" or "[C". Lazily initialized by ComputeName
    HeapReference<String> name_;

    // The superclass, or null if this is java.lang.Object or a primitive type.
    //
    // Note that interfaces have java.lang.Object as their
    // superclass. This doesn't match the expectations in JNI
    // GetSuperClass or java.lang.Class.getSuperClass() which need to
    // check for interfaces and return null.
    HeapReference<Class> super_class_;

    // Virtual method table (vtable), for use by "invoke-virtual".  The vtable from the superclass is
    // copied in, and virtual methods from our class either replace those from the super or are
    // appended. For abstract classes, methods may be created in the vtable that aren't in
    // virtual_ methods_ for miranda methods.
    HeapReference<PointerArray> vtable_;

    // instance fields
    //
    // These describe the layout of the contents of an Object.
    // Note that only the fields directly declared by this class are
    // listed in ifields; fields declared by a superclass are listed in
    // the superclass's Class.ifields.
    //
    // ArtFields are allocated as a length prefixed ArtField array, and not an array of pointers to
    // ArtFields.
    uint64_t ifields_;

    // Pointer to an ArtMethod length-prefixed array. All the methods where this class is the place
    // where they are logically defined. This includes all private, static, final and virtual methods
    // as well as inherited default methods and miranda methods.
    //
    // The slice methods_ [0, virtual_methods_offset_) are the direct (static, private, init) methods
    // declared by this class.
    //
    // The slice methods_ [virtual_methods_offset_, copied_methods_offset_) are the virtual methods
    // declared by this class.
    //
    // The slice methods_ [copied_methods_offset_, |methods_|) are the methods that are copied from
    // interfaces such as miranda or default methods. These are copied for resolution purposes as this
    // class is where they are (logically) declared as far as the virtual dispatch is concerned.
    //
    // Note that this field is used by the native debugger as the unique identifier for the type.
    uint64_t methods_;

    // Static fields length-prefixed array.
    uint64_t sfields_;

    // Access flags; low 16 bits are defined by VM spec.
    uint32_t access_flags_;

    // Class flags to help speed up visiting object references.
    uint32_t class_flags_;

    // Total size of the Class instance; used when allocating storage on gc heap.
    // See also object_size_.
    uint32_t class_size_;

    // Tid used to check for recursive <clinit> invocation.
    pid_t clinit_thread_id_;
    static_assert(sizeof(pid_t) == sizeof(int32_t), "java.lang.Class.clinitThreadId size check");

    // ClassDef index in dex file, -1 if no class definition such as an array.
    // TODO: really 16bits
    int32_t dex_class_def_idx_;

    // Type index in dex file.
    // TODO: really 16bits
    int32_t dex_type_idx_;

    // Number of instance fields that are object refs.
    uint32_t num_reference_instance_fields_;

    // Number of static fields that are object refs,
    uint32_t num_reference_static_fields_;

    // Total object size; used when allocating storage on gc heap.
    // (For interfaces and abstract classes this will be zero.)
    // See also class_size_.
    uint32_t object_size_;

    // Aligned object size for allocation fast path. The value is max uint32_t if the object is
    // uninitialized or finalizable. Not currently used for variable sized objects.
    uint32_t object_size_alloc_fast_path_;

    // The lower 16 bits contains a Primitive::Type value. The upper 16
    // bits contains the size shift of the primitive type.
    uint32_t primitive_type_;

    // Bitmap of offsets of ifields.
    uint32_t reference_instance_offsets_;

    // See the real definition in subtype_check_bits_and_status.h
    // typeof(status_) is actually SubtypeCheckBitsAndStatus.
    uint32_t status_;

    // The offset of the first virtual method that is copied from an interface. This includes miranda,
    // default, and default-conflict methods. Having a hard limit of ((2 << 16) - 1) for methods
    // defined on a single class is well established in Java so we will use only uint16_t's here.
    uint16_t copied_methods_offset_;

    // The offset of the first declared virtual methods in the methods_ array.
    uint16_t virtual_methods_offset_;
};